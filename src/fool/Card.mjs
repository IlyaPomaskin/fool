// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/belt_List.js";

var suitsList = {
  hd: /* Spades */0,
  tl: {
    hd: /* Hearts */1,
    tl: {
      hd: /* Diamonds */2,
      tl: {
        hd: /* Clubs */3,
        tl: /* [] */0
      }
    }
  }
};

var ranksList = {
  hd: /* Six */0,
  tl: {
    hd: /* Seven */1,
    tl: {
      hd: /* Eight */2,
      tl: {
        hd: /* Nine */3,
        tl: {
          hd: /* Ten */4,
          tl: {
            hd: /* Jack */5,
            tl: {
              hd: /* Queen */6,
              tl: {
                hd: /* King */7,
                tl: {
                  hd: /* Ace */8,
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    }
  }
};

function makeShuffledDeck(param) {
  var suits = Belt_List.flatten(Belt_List.make(9, suitsList));
  var ranks = Belt_List.flatten(Belt_List.make(4, ranksList));
  return Belt_List.shuffle(Belt_List.reduce2(suits, ranks, /* [] */0, (function (acc, suit, rank) {
                    return Belt_List.add(acc, [
                                suit,
                                rank
                              ]);
                  })));
}

function dealCards(amount, deck) {
  var cardsToDeal = Belt_List.keepWithIndex(deck, (function (param, index) {
          return index <= amount;
        }));
  var nextDeck = Belt_List.keepWithIndex(deck, (function (param, index) {
          return index > amount;
        }));
  return [
          cardsToDeal,
          nextDeck
        ];
}

function isCardEqualsBySuit(param, param$1) {
  return param[0] === param$1[0];
}

function isCardEqualsByRank(param, param$1) {
  return param[1] === param$1[1];
}

function isCardEquals(first, second) {
  if (isCardEqualsBySuit(first, second)) {
    return isCardEqualsByRank(first, second);
  } else {
    return false;
  }
}

function ltCardByRank(param, param$1) {
  return param[1] < param$1[1];
}

function sortCardsByRank(first, second) {
  if (ltCardByRank(first, second)) {
    return -1;
  } else {
    return 1;
  }
}

function removeCard(removedCard, deck) {
  return Belt_List.keep(deck, (function (card) {
                return !isCardEquals(card, removedCard);
              }));
}

function isAllCardsAreBeat(table) {
  return Belt_List.every(table, (function (param) {
                var by = param[1];
                if (by !== undefined) {
                  return !ltCardByRank(param[0], by);
                } else {
                  return false;
                }
              }));
}

function isTrump(trump, param) {
  return trump === param[0];
}

function getSmallestCard(trump, first, second) {
  if (first === undefined) {
    if (second !== undefined) {
      return second;
    } else {
      return ;
    }
  }
  if (second === undefined) {
    return first;
  }
  var isFstTrump = isTrump(trump, first);
  var isSndTrump = isTrump(trump, second);
  if (isFstTrump) {
    if (isSndTrump && !ltCardByRank(first, second)) {
      return second;
    } else {
      return first;
    }
  } else if (isSndTrump || !ltCardByRank(first, second)) {
    return second;
  } else {
    return first;
  }
}

function getSmallestValuableCard(trump, deck) {
  return Belt_List.reduce(Belt_List.map(deck, (function (card) {
                    return card;
                  })), undefined, (function (prev, next) {
                var nextSmallestCard = getSmallestCard(trump, prev, next);
                if (prev !== undefined) {
                  if (nextSmallestCard !== undefined) {
                    return nextSmallestCard;
                  } else {
                    return prev;
                  }
                } else if (nextSmallestCard !== undefined) {
                  return nextSmallestCard;
                } else {
                  return ;
                }
              }));
}

function isBeatByTrump(to, by, trump) {
  if (to[0] !== trump) {
    return by[0] === trump;
  } else {
    return false;
  }
}

function isValidTableBeat(to, by, trump) {
  if (isCardEqualsBySuit(to, by) && ltCardByRank(to, by)) {
    return isBeatByTrump(to, by, trump);
  } else {
    return false;
  }
}

function getFlatTableCards(table) {
  return Belt_List.keepMap(Belt_List.flatten(Belt_List.map(table, (function (param) {
                        return {
                                hd: param[0],
                                tl: {
                                  hd: param[1],
                                  tl: /* [] */0
                                }
                              };
                      }))), (function (c) {
                return c;
              }));
}

function suitToString(suit) {
  switch (suit) {
    case /* Spades */0 :
        return "♠";
    case /* Hearts */1 :
        return "♥";
    case /* Diamonds */2 :
        return "♦";
    case /* Clubs */3 :
        return "♣";
    
  }
}

function rankToString(rank) {
  switch (rank) {
    case /* Six */0 :
        return "6";
    case /* Seven */1 :
        return "7";
    case /* Eight */2 :
        return "8";
    case /* Nine */3 :
        return "9";
    case /* Ten */4 :
        return "10";
    case /* Jack */5 :
        return "J";
    case /* Queen */6 :
        return "Q";
    case /* King */7 :
        return "K";
    case /* Ace */8 :
        return "A";
    
  }
}

function cardToString(param) {
  return suitToString(param[0]) + " " + rankToString(param[1]);
}

function isDeckEmpty(deck) {
  return Belt_List.length(deck) === 0;
}

export {
  suitsList ,
  ranksList ,
  makeShuffledDeck ,
  dealCards ,
  isCardEqualsBySuit ,
  isCardEqualsByRank ,
  isCardEquals ,
  ltCardByRank ,
  sortCardsByRank ,
  removeCard ,
  isAllCardsAreBeat ,
  isTrump ,
  getSmallestCard ,
  getSmallestValuableCard ,
  isBeatByTrump ,
  isValidTableBeat ,
  getFlatTableCards ,
  suitToString ,
  rankToString ,
  cardToString ,
  isDeckEmpty ,
  
}
/* No side effect */
