// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "./Card.mjs";
import * as Deck from "./Deck.mjs";
import * as Table from "./Table.mjs";
import * as Utils from "../Utils.mjs";
import * as Player from "./Player.mjs";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as MResult from "../MResult.mjs";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as GameUtils from "./GameUtils.mjs";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";

function makeGameInLobby(player) {
  return MResult.makeOk({
              TAG: /* InLobby */0,
              _0: {
                owner: player.id,
                gameId: "g" + String(Js_math.random_int(0, 100)),
                players: {
                  hd: player,
                  tl: /* [] */0
                },
                ready: {
                  hd: player.id,
                  tl: /* [] */0
                }
              }
            });
}

function enterLobby(game, player) {
  var isPlayerInGame = Belt_List.has(game.players, player, Player.equals);
  return MResult.makeOk({
              TAG: /* InLobby */0,
              _0: {
                owner: game.owner,
                gameId: game.gameId,
                players: isPlayerInGame ? game.players : Belt_List.add(game.players, player),
                ready: game.ready
              }
            });
}

function leaveLobby(game, player) {
  return {
          TAG: /* Ok */0,
          _0: {
            TAG: /* InLobby */0,
            _0: {
              owner: game.owner,
              gameId: game.gameId,
              players: Belt_List.keep(game.players, (function (item) {
                      return item !== player;
                    })),
              ready: game.ready
            }
          }
        };
}

function disconnectProgress(game, player) {
  return Belt_Result.map(MResult.validate(MResult.makeOk(game), "Player not in game", (function (g) {
                    return Belt_List.has(g.players, player, Player.equals);
                  })), (function (game) {
                var isDisconnected = Belt_List.has(game.disconnected, player.id, Utils.equals);
                return {
                        TAG: /* InProgress */1,
                        _0: {
                          gameId: game.gameId,
                          attacker: game.attacker,
                          defender: game.defender,
                          players: game.players,
                          disconnected: isDisconnected ? game.disconnected : Belt_List.add(game.disconnected, player.id),
                          trump: game.trump,
                          deck: game.deck,
                          table: game.table,
                          pass: game.pass
                        }
                      };
              }));
}

function enterProgress(game, player) {
  return Belt_Result.map(MResult.validate(MResult.makeOk(game), "Player not in game", (function (g) {
                    return Belt_List.has(g.players, player, Player.equals);
                  })), (function (game) {
                var isDisconnected = Belt_List.has(game.disconnected, player.id, Utils.equals);
                return {
                        TAG: /* InProgress */1,
                        _0: {
                          gameId: game.gameId,
                          attacker: game.attacker,
                          defender: game.defender,
                          players: game.players,
                          disconnected: isDisconnected ? Belt_List.keep(game.disconnected, (function (pId) {
                                    return pId !== player.id;
                                  })) : game.disconnected,
                          trump: game.trump,
                          deck: game.deck,
                          table: game.table,
                          pass: game.pass
                        }
                      };
              }));
}

function isValidToggleReady(game, player) {
  return MResult.validate({
              TAG: /* Ok */0,
              _0: game
            }, "Player not in game", (function (g) {
                return !Belt_List.has(g.players, player, Player.equals);
              }));
}

function toggleReady(game, player) {
  return Belt_Result.map(Belt_Result.flatMap(MResult.makeOk(game), (function (lobby) {
                    return isValidToggleReady(lobby, player);
                  })), (function (lobby) {
                var inList = Belt_List.has(lobby.ready, player.id, Utils.equals);
                return {
                        TAG: /* InLobby */0,
                        _0: {
                          owner: lobby.owner,
                          gameId: lobby.gameId,
                          players: lobby.players,
                          ready: inList ? Belt_List.keep(lobby.ready, (function (pId) {
                                    return pId !== player.id;
                                  })) : Belt_List.add(lobby.ready, player.id)
                        }
                      };
              }));
}

function startGame(game, playerId) {
  return Belt_Result.flatMap(Belt_Result.flatMap(MResult.makeOk(game), (function (lobby) {
                    return GameUtils.isCanStart(lobby, playerId);
                  })), (function (game) {
                var match = Player.dealDeckToPlayers(Deck.makeShuffled(undefined), game.players);
                var deck = match[1];
                var players = match[0];
                var trump = GameUtils.getTrump(deck, players);
                var attacker = Belt_Option.flatMap(trump, (function (tr) {
                        return Player.findFirstAttackerId(tr, players);
                      }));
                var defender = Belt_Option.flatMap(attacker, (function (at) {
                        return Player.getNextPlayerId(at, players);
                      }));
                if (trump !== undefined) {
                  if (attacker !== undefined && defender !== undefined) {
                    return {
                            TAG: /* Ok */0,
                            _0: {
                              TAG: /* InProgress */1,
                              _0: {
                                gameId: game.gameId,
                                attacker: attacker,
                                defender: defender,
                                players: players,
                                disconnected: /* [] */0,
                                trump: trump,
                                deck: deck,
                                table: /* [] */0,
                                pass: /* [] */0
                              }
                            }
                          };
                  } else {
                    return {
                            TAG: /* Error */1,
                            _0: "Can't find next attacker/defender"
                          };
                  }
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "Can't find trump"
                        };
                }
              }));
}

function isValidMove(game, player, card) {
  return MResult.validate(MResult.validate(MResult.validate(MResult.validate(MResult.validate(MResult.validate({
                                  TAG: /* Ok */0,
                                  _0: game
                                }, "Defender can't make move", (function (g) {
                                    return GameUtils.isDefender(g, player);
                                  })), "First move made not by attacker", (function (g) {
                                if (Table.hasCards(g.table)) {
                                  return false;
                                } else {
                                  return !GameUtils.isAttacker(g, player);
                                }
                              })), "Maximum cards on table", (function (g) {
                            return Table.isMaximumCards(g.table);
                          })), "Defender don't have enough cards", (function (g) {
                        return !Belt_Option.getWithDefault(Belt_Option.map(Player.getById(g.players, g.defender), (function (defender) {
                                          return Belt_List.length(defender.cards) >= (Belt_List.length(g.table) + 1 | 0);
                                        })), false);
                      })), "Player don't have card", (function (param) {
                    return !GameUtils.isPlayerHasCard(player, card);
                  })), "Incorrect card", (function (g) {
                if (Table.hasCards(g.table)) {
                  return !GameUtils.isCorrectAdditionalCard(g, card);
                } else {
                  return false;
                }
              }));
}

function move(game, player, card) {
  return Belt_Result.map(Belt_Result.flatMap({
                  TAG: /* Ok */0,
                  _0: game
                }, (function (game) {
                    return isValidMove(game, player, card);
                  })), (function (game) {
                return {
                        gameId: game.gameId,
                        attacker: game.attacker,
                        defender: game.defender,
                        players: Belt_List.map(game.players, (function (p) {
                                return Player.removeCard(p, card);
                              })),
                        disconnected: game.disconnected,
                        trump: game.trump,
                        deck: game.deck,
                        table: Belt_List.add(game.table, [
                              card,
                              undefined
                            ]),
                        pass: game.pass
                      };
              }));
}

function isValidPass(game, player) {
  return MResult.validate({
              TAG: /* Ok */0,
              _0: game
            }, "Can't pass", (function (g) {
                return !GameUtils.isCanPass(g, player);
              }));
}

function finishRound(game) {
  var nextAttacker = Player.getNextPlayerId(game.attacker, game.players);
  var nextDefender = Belt_Option.flatMap(nextAttacker, (function (p) {
          return Player.getNextPlayerId(p, game.players);
        }));
  var match = Player.dealDeckToPlayers(game.deck, game.players);
  if (nextAttacker !== undefined && nextDefender !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: {
              gameId: game.gameId,
              attacker: nextAttacker,
              defender: nextDefender,
              players: match[0],
              disconnected: game.disconnected,
              trump: game.trump,
              deck: match[1],
              table: /* [] */0,
              pass: /* [] */0
            }
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: "Can't find next attacker/defender"
          };
  }
}

function pass(game, player) {
  return Belt_Result.flatMap(Belt_Result.flatMap({
                  TAG: /* Ok */0,
                  _0: game
                }, (function (game) {
                    return isValidPass(game, player);
                  })), (function (game) {
                var nextGameWithPassed_gameId = game.gameId;
                var nextGameWithPassed_attacker = game.attacker;
                var nextGameWithPassed_defender = game.defender;
                var nextGameWithPassed_players = game.players;
                var nextGameWithPassed_disconnected = game.disconnected;
                var nextGameWithPassed_trump = game.trump;
                var nextGameWithPassed_deck = game.deck;
                var nextGameWithPassed_table = game.table;
                var nextGameWithPassed_pass = Utils.toggleListItem(game.pass, player.id);
                var nextGameWithPassed = {
                  gameId: nextGameWithPassed_gameId,
                  attacker: nextGameWithPassed_attacker,
                  defender: nextGameWithPassed_defender,
                  players: nextGameWithPassed_players,
                  disconnected: nextGameWithPassed_disconnected,
                  trump: nextGameWithPassed_trump,
                  deck: nextGameWithPassed_deck,
                  table: nextGameWithPassed_table,
                  pass: nextGameWithPassed_pass
                };
                if (GameUtils.isAllPassed(nextGameWithPassed) && Table.isAllBeaten(game.table)) {
                  return finishRound(nextGameWithPassed);
                } else {
                  return {
                          TAG: /* Ok */0,
                          _0: nextGameWithPassed
                        };
                }
              }));
}

function isValidBeat(game, player, to, by) {
  return MResult.validate(MResult.validate(MResult.validate({
                      TAG: /* Ok */0,
                      _0: game
                    }, "Is not deffender", (function (g) {
                        return !GameUtils.isDefender(g, player);
                      })), "Player dont have card", (function (param) {
                    return !GameUtils.isPlayerHasCard(player, by);
                  })), "Invalid card beat", (function (g) {
                return !Card.isValidBeat(to, by, g.trump);
              }));
}

function beat(game, player, to, by) {
  return Belt_Result.map(Belt_Result.flatMap({
                  TAG: /* Ok */0,
                  _0: game
                }, (function (game) {
                    return isValidBeat(game, player, to, by);
                  })), (function (game) {
                return {
                        gameId: game.gameId,
                        attacker: game.attacker,
                        defender: game.defender,
                        players: Belt_List.map(game.players, (function (p) {
                                if (Player.equals(p, player)) {
                                  return Player.removeCard(player, by);
                                } else {
                                  return p;
                                }
                              })),
                        disconnected: game.disconnected,
                        trump: game.trump,
                        deck: game.deck,
                        table: Belt_List.map(game.table, (function (param) {
                                var firstCard = param[0];
                                if (Card.isEquals(firstCard, to)) {
                                  return [
                                          firstCard,
                                          by
                                        ];
                                } else {
                                  return [
                                          firstCard,
                                          param[1]
                                        ];
                                }
                              })),
                        pass: /* [] */0
                      };
              }));
}

function isValidTake(game, player) {
  return MResult.validate(MResult.validate({
                  TAG: /* Ok */0,
                  _0: game
                }, "Player is not defender", (function (g) {
                    return !GameUtils.isDefender(g, player);
                  })), "Table is empty", (function (g) {
                return !Table.hasCards(g.table);
              }));
}

function take(game, player) {
  return Belt_Result.flatMap(Belt_Result.flatMap({
                  TAG: /* Ok */0,
                  _0: game
                }, (function (game) {
                    return isValidTake(game, player);
                  })), (function (game) {
                var nextAttacker = Player.getNextPlayerId(game.defender, game.players);
                var nextDefender = Belt_Option.flatMap(nextAttacker, (function (p) {
                        return Player.getNextPlayerId(p, game.players);
                      }));
                var nextPlayers = Belt_List.map(game.players, (function (p) {
                        if (GameUtils.isDefender(game, p)) {
                          return {
                                  id: p.id,
                                  sessionId: p.sessionId,
                                  cards: Belt_List.concat(p.cards, Table.getFlatCards(game.table))
                                };
                        } else {
                          return p;
                        }
                      }));
                var match = Player.dealDeckToPlayers(game.deck, nextPlayers);
                if (nextAttacker !== undefined && nextDefender !== undefined) {
                  return {
                          TAG: /* Ok */0,
                          _0: {
                            gameId: game.gameId,
                            attacker: nextAttacker,
                            defender: nextDefender,
                            players: match[0],
                            disconnected: game.disconnected,
                            trump: game.trump,
                            deck: match[1],
                            table: /* [] */0,
                            pass: /* [] */0
                          }
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "Can't find next attacker/defender"
                        };
                }
              }));
}

function dispatch(game, player, action) {
  var tmp;
  tmp = typeof action === "number" ? (
      action === /* Take */0 ? take(game, player) : pass(game, player)
    ) : (
      action.TAG === /* Beat */0 ? beat(game, player, action._0, action._1) : move(game, player, action._0)
    );
  return Belt_Result.map(tmp, (function (game) {
                return {
                        TAG: /* InProgress */1,
                        _0: game
                      };
              }));
}

function maskGameDeck(deck) {
  var lastCardIndex = Belt_List.length(deck) - 1 | 0;
  return Belt_List.mapWithIndex(deck, (function (index, card) {
                if (index === lastCardIndex) {
                  return card;
                } else {
                  return /* Hidden */0;
                }
              }));
}

function maskForPlayer(game, playerId) {
  return {
          gameId: game.gameId,
          attacker: game.attacker,
          defender: game.defender,
          players: Belt_List.map(game.players, (function (param) {
                  return Player.mask(playerId, param);
                })),
          disconnected: game.disconnected,
          trump: game.trump,
          deck: maskGameDeck(game.deck),
          table: game.table,
          pass: game.pass
        };
}

function toObject(game) {
  return {
          gameId: game.gameId,
          table: Table.toObject(game.table),
          trump: Card.suitToString(game.trump),
          attacker: game.attacker,
          defender: game.defender,
          players: Belt_List.toArray(Belt_List.map(game.players, Player.toObject)),
          deck: Deck.toObject(game.deck),
          pass: Belt_List.toArray(game.pass)
        };
}

function actionToObject(action) {
  if (typeof action === "number") {
    if (action === /* Take */0) {
      return "take";
    } else {
      return "pass";
    }
  } else if (action.TAG === /* Beat */0) {
    return "beat to:" + Card.cardToString(action._0) + " by:" + Card.cardToString(action._1);
  } else {
    return "move " + Card.cardToString(action._0);
  }
}

export {
  makeGameInLobby ,
  enterLobby ,
  leaveLobby ,
  disconnectProgress ,
  enterProgress ,
  isValidToggleReady ,
  toggleReady ,
  startGame ,
  isValidMove ,
  move ,
  isValidPass ,
  finishRound ,
  pass ,
  isValidBeat ,
  beat ,
  isValidTake ,
  take ,
  dispatch ,
  maskGameDeck ,
  maskForPlayer ,
  toObject ,
  actionToObject ,
  
}
/* Table Not a pure module */
