// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "./Card.mjs";
import * as Utils from "./Utils.mjs";
import * as Player from "./Player.mjs";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";

function makeGameInLobby(authorId) {
  return {
          TAG: /* InLobby */0,
          _0: {
            players: {
              hd: Player.make(authorId),
              tl: /* [] */0
            },
            ready: /* [] */0
          }
        };
}

function logoutPlayer(game, player) {
  return {
          TAG: /* InLobby */0,
          _0: {
            players: Belt_List.keep(game.players, (function (item) {
                    return item !== player;
                  })),
            ready: game.ready
          }
        };
}

function enterGame(game, player) {
  return {
          TAG: /* InLobby */0,
          _0: {
            players: Belt_List.add(game.players, player),
            ready: game.ready
          }
        };
}

function toggleReady(game, player) {
  return {
          TAG: /* InLobby */0,
          _0: {
            players: Utils.toggleArrayItem(game.players, player),
            ready: game.ready
          }
        };
}

function lastListItem(list) {
  return Belt_List.get(list, Belt_List.size(list) - 1 | 0);
}

function getTrump(deck, players) {
  var lastCard = lastListItem(deck);
  var lastPlayer = lastListItem(Belt_List.keep(players, (function (p) {
              return Belt_List.length(p.cards) !== 0;
            })));
  if (lastCard !== undefined) {
    return lastCard[0];
  } else if (lastPlayer !== undefined) {
    return Belt_Option.map(lastListItem(lastPlayer.cards), (function (prim) {
                  return prim[0];
                }));
  } else {
    return ;
  }
}

function startGame(game) {
  var match = Player.dealDeckToPlayers(Card.makeShuffledDeck(undefined), game.players);
  var deck = match[1];
  var players = match[0];
  var trump = Belt_Option.mapWithDefault(getTrump(deck, players), {
        TAG: /* Error */1,
        _0: "No trump"
      }, Utils.makeOk);
  var attacker = Belt_Result.flatMap(trump, (function (r) {
          return Belt_Option.mapWithDefault(Player.findFirstAttacker(r, players), {
                      TAG: /* Error */1,
                      _0: "No attacker"
                    }, Utils.makeOk);
        }));
  var defender = Belt_Result.flatMap(attacker, (function (a) {
          return Belt_Option.mapWithDefault(Player.getNextPlayer(a, players), {
                      TAG: /* Error */1,
                      _0: "No deffender"
                    }, Utils.makeOk);
        }));
  if (trump.TAG === /* Ok */0) {
    if (attacker.TAG === /* Ok */0) {
      if (defender.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: {
                  TAG: /* InProgress */1,
                  _0: {
                    attacker: attacker._0,
                    defender: defender._0,
                    players: players,
                    trump: trump._0,
                    deck: deck,
                    table: /* [] */0,
                    pass: /* [] */0
                  }
                }
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: defender._0
              };
      }
    } else {
      return {
              TAG: /* Error */1,
              _0: attacker._0
            };
    }
  } else {
    return {
            TAG: /* Error */1,
            _0: trump._0
          };
  }
}

function isDefender(game, player) {
  return Caml_obj.caml_equal(game.defender, player);
}

function isAttacker(game, player) {
  return Caml_obj.caml_equal(game.attacker, player);
}

function isPlayerHasCard(player, card) {
  return Belt_List.has(player.cards, card, Utils.equals);
}

function isCorrectAdditionalCard(game, card) {
  return Belt_List.has(Card.getFlatTableCards(game.table), card, Card.isCardEqualsByRank);
}

function isFirstMove(game) {
  return Belt_List.length(game.table) === 0;
}

function isValidMove(game, player, card) {
  if (Caml_obj.caml_equal(game.defender, player)) {
    return {
            TAG: /* Error */1,
            _0: "Defender can't make move"
          };
  } else if (isFirstMove(game) && !Caml_obj.caml_equal(game.attacker, player)) {
    return {
            TAG: /* Error */1,
            _0: "First move made not by attacker"
          };
  } else if (isPlayerHasCard(player, card)) {
    if (!isFirstMove(game) && !isCorrectAdditionalCard(game, card)) {
      return {
              TAG: /* Error */1,
              _0: "Incorrect card"
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: {
                TAG: /* InProgress */1,
                _0: game
              }
            };
    }
  } else {
    return {
            TAG: /* Error */1,
            _0: "Player don't have card"
          };
  }
}

function move(game, player, card) {
  var isValid = isValidMove(game, player, card);
  if (Belt_Result.isError(isValid)) {
    return isValid;
  } else {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* InProgress */1,
              _0: {
                attacker: game.attacker,
                defender: game.defender,
                players: Belt_List.map(game.players, (function (p) {
                        return {
                                id: p.id,
                                sessionId: p.sessionId,
                                cards: Player.removeCard(p, card)
                              };
                      })),
                trump: game.trump,
                deck: game.deck,
                table: Belt_List.add(game.table, [
                      card,
                      undefined
                    ]),
                pass: game.pass
              }
            }
          };
  }
}

function isValidPass(game, player) {
  if (Caml_obj.caml_equal(game.defender, player)) {
    return {
            TAG: /* Error */1,
            _0: "Defender can't pass"
          };
  } else if (Player.isPlayerExists(game.players, player)) {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* InProgress */1,
              _0: game
            }
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: "Player doesn't exists "
          };
  }
}

function pass(game, player) {
  var isValid = isValidPass(game, player);
  if (Belt_Result.isError(isValid)) {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* InProgress */1,
              _0: {
                attacker: game.attacker,
                defender: game.defender,
                players: game.players,
                trump: game.trump,
                deck: game.deck,
                table: game.table,
                pass: Belt_List.add(game.pass, player)
              }
            }
          };
  } else {
    return isValid;
  }
}

function isValidBeat(game, to, by, player) {
  if (Caml_obj.caml_equal(game.defender, player)) {
    if (isPlayerHasCard(player, by)) {
      return {
              TAG: /* Error */1,
              _0: "Player dont have card"
            };
    } else if (Card.isValidTableBeat(to, by, game.trump)) {
      return {
              TAG: /* Error */1,
              _0: "Wrong card to beat"
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: {
                TAG: /* InProgress */1,
                _0: game
              }
            };
    }
  } else {
    return {
            TAG: /* Error */1,
            _0: "Is not deffender"
          };
  }
}

function beat(game, to, by, player) {
  var isValid = isValidBeat(game, to, by, player);
  if (Belt_Result.isError(isValid)) {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* InProgress */1,
              _0: {
                attacker: game.attacker,
                defender: game.defender,
                players: Belt_List.map(game.players, (function (p) {
                        return {
                                id: p.id,
                                sessionId: p.sessionId,
                                cards: Player.removeCard(p, by)
                              };
                      })),
                trump: game.trump,
                deck: game.deck,
                table: Belt_List.map(game.table, (function (param) {
                        var firstCard = param[0];
                        if (Card.isCardEquals(firstCard, to)) {
                          return [
                                  firstCard,
                                  by
                                ];
                        } else {
                          return [
                                  firstCard,
                                  param[1]
                                ];
                        }
                      })),
                pass: game.pass
              }
            }
          };
  } else {
    return isValid;
  }
}

function isValidTake(game, player) {
  if (Caml_obj.caml_equal(game.defender, player)) {
    return {
            TAG: /* Error */1,
            _0: "Player is not defender"
          };
  } else {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* InProgress */1,
              _0: game
            }
          };
  }
}

function take(game, player) {
  var isValid = isValidTake(game, player);
  if (Belt_Result.isError(isValid)) {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* InProgress */1,
              _0: {
                attacker: game.attacker,
                defender: game.defender,
                players: Belt_List.map(game.players, (function (p) {
                        if (Caml_obj.caml_equal(game.defender, p)) {
                          return {
                                  id: p.id,
                                  sessionId: p.sessionId,
                                  cards: Belt_List.concat(p.cards, Card.getFlatTableCards(game.table))
                                };
                        } else {
                          return p;
                        }
                      })),
                trump: game.trump,
                deck: game.deck,
                table: /* [] */0,
                pass: game.pass
              }
            }
          };
  } else {
    return isValid;
  }
}

export {
  makeGameInLobby ,
  logoutPlayer ,
  enterGame ,
  toggleReady ,
  lastListItem ,
  getTrump ,
  startGame ,
  isDefender ,
  isAttacker ,
  isPlayerHasCard ,
  isCorrectAdditionalCard ,
  isFirstMove ,
  isValidMove ,
  move ,
  isValidPass ,
  pass ,
  isValidBeat ,
  beat ,
  isValidTake ,
  take ,
  
}
/* No side effect */
