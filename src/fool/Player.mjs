// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as Card from "./Card.mjs";
import * as Deck from "./Deck.mjs";
import * as Utils from "../Utils.mjs";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function make(login) {
  return {
          id: login,
          sessionId: "session:" + String(Js_math.random_int(0, 10000000)),
          cards: /* [] */0
        };
}

function getNextPlayer(p, players) {
  var playersWithCards = Belt_List.keep(players, (function (p) {
          return Belt_List.length(p.cards) !== 0;
        }));
  var foundPlayerIndex = Belt_List.reduceWithIndex(playersWithCards, -1, (function (prev, item, index) {
          if (item.id === p.id) {
            return index;
          } else {
            return prev;
          }
        }));
  var nextPlayer = Belt_List.get(playersWithCards, foundPlayerIndex + 1 | 0);
  if (nextPlayer !== undefined) {
    return nextPlayer;
  } else {
    return Belt_List.get(playersWithCards, 0);
  }
}

function findFirstAttacker(trump, players) {
  return Belt_List.reduce(players, Belt_List.get(players, 0), (function (prev, next) {
                var prevSmallestCard = Deck.getSmallestValuableCard(trump, Belt_Option.getWithDefault(Belt_Option.map(prev, (function (a) {
                                return a.cards;
                              })), /* [] */0));
                var nextSmallestCard = Deck.getSmallestValuableCard(trump, next.cards);
                var smallestCard = Card.getSmallest(trump, prevSmallestCard, nextSmallestCard);
                if (smallestCard === nextSmallestCard) {
                  return next;
                } else {
                  return prev;
                }
              }));
}

function dealToPlayer(deck, player) {
  var requiredCardsAmount = Caml.caml_int_max(0, 6 - Belt_List.length(player.cards) | 0);
  var match = Deck.dealCards(requiredCardsAmount, deck);
  return [
          {
            id: player.id,
            sessionId: player.sessionId,
            cards: Belt_List.concat(player.cards, match[0])
          },
          match[1]
        ];
}

function dealDeckToPlayers(deck, players) {
  var match = Belt_List.reduce(players, [
        [],
        deck
      ], (function (param, player) {
          var match = dealToPlayer(param[1], player);
          return [
                  Belt_Array.concat(param[0], [match[0]]),
                  match[1]
                ];
        }));
  return [
          Belt_List.fromArray(match[0]),
          match[1]
        ];
}

function removeCard(player, card) {
  return Belt_List.keep(player.cards, (function (c) {
                return !Card.isEquals(card, c);
              }));
}

function isPlayerExists(players, player) {
  return Belt_List.has(players, player, Utils.equals);
}

function equals(a, b) {
  return a.id === b.id;
}

function mask(playerId, player) {
  return {
          id: player.id,
          sessionId: playerId === player.id ? player.sessionId : "masked",
          cards: Belt_List.map(player.cards, (function (card) {
                  if (player.id === playerId) {
                    return card;
                  } else {
                    return /* Hidden */0;
                  }
                }))
        };
}

function toObject(player) {
  return {
          id: player.id,
          sessionId: player.sessionId,
          cards: Belt_List.toArray(Belt_List.map(player.cards, Card.cardToString))
        };
}

function toStringShort(player) {
  return {
          id: player.id,
          sessionId: player.sessionId
        };
}

export {
  make ,
  getNextPlayer ,
  findFirstAttacker ,
  dealToPlayer ,
  dealDeckToPlayers ,
  removeCard ,
  isPlayerExists ,
  equals ,
  mask ,
  toObject ,
  toStringShort ,
  
}
/* No side effect */
